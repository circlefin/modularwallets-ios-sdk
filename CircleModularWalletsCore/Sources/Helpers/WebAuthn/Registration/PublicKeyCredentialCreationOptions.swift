//
// Copyright (c) 2025, Circle Internet Group, Inc. All rights reserved.
//
// SPDX-License-Identifier: Apache-2.0
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift WebAuthn open source project
//
// Copyright (c) 2022 the Swift WebAuthn project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Swift WebAuthn project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

import Foundation

/// The `PublicKeyCredentialCreationOptions` gets passed to the WebAuthn API (`navigator.credentials.create()`)
///
/// - SeeAlso: https://www.w3.org/TR/webauthn-2/#dictionary-makecredentialoptions
public struct PublicKeyCredentialCreationOptions: Codable, Sendable {
    /// A byte array randomly generated by the Relying Party. Should be at least 16 bytes long to ensure sufficient
    /// entropy.
    ///
    /// The Relying Party should store the challenge temporarily until the registration flow is complete.
    public let challenge: URLEncodedBase64

    /// Contains a name and an identifier for the Relying Party responsible for the request
    public let relyingParty: PublicKeyCredentialRelyingPartyEntity

    /// A list of key types and signature algorithms the Relying Party supports. Ordered from most preferred to least
    /// preferred.
    public let publicKeyCredentialParameters: [PublicKeyCredentialParameters]

    /// Contains names and an identifier for the user account performing the registration
    public let user: PublicKeyCredentialUserEntity

    /// This member is intended for use by Relying Parties that wish to select the appropriate authenticators to 
    /// participate in the create() operation.
    public let authenticatorSelectionCriteria: AuthenticatorSelectionCriteria?

    /// A time, in seconds, that the caller is willing to wait for the call to complete. This is treated as a
    /// hint, and may be overridden by the client.
    ///
    /// - Note: When encoded, this value is represented in milleseconds as a ``UInt32``.
    /// See https://www.w3.org/TR/webauthn-2/#dictionary-assertion-options
    public let timeout: Duration?

    /// This member is intended for use by Relying Parties that wish to limit the creation of
    /// multiple credentials for the same account on a single authenticator.
    public let excludeCredentials: [PublicKeyCredentialDescriptor]?

    /// This member is intended for use by Relying Parties that wish to express their preference for attestation conveyance.
    public let attestation: String?

    /// This member contains additional parameters requesting additional processing by the client and authenticator.
    //public let extensions: [String: Any]?

    private enum CodingKeys: String, CodingKey {
        case challenge
        case relyingParty = "rp"
        case publicKeyCredentialParameters = "pubKeyCredParams"
        case user
        case authenticatorSelectionCriteria = "authenticatorSelection"
        case timeout
        case excludeCredentials
        case attestation
    }

//    init(challenge: URLEncodedBase64,
//         relyingParty: PublicKeyCredentialRelyingPartyEntity,
//         publicKeyCredentialParameters: [PublicKeyCredentialParameters],
//         user: PublicKeyCredentialUserEntity,
//         authenticatorSelectionCriteria: AuthenticatorSelectionCriteria? = nil,
//         timeout: Duration? = nil,
//         excludeCredentials: [PublicKeyCredentialDescriptor]? = nil,
//         attestation: String? = nil) {
//        self.challenge = challenge
//        self.relyingParty = relyingParty
//        self.publicKeyCredentialParameters = publicKeyCredentialParameters
//        self.user = user
//        self.authenticatorSelectionCriteria = authenticatorSelectionCriteria
//        self.timeout = timeout
//        self.excludeCredentials = excludeCredentials
//        self.attestation = attestation
//    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        let challengeStr = try container.decode(String.self, forKey: .challenge)
        challenge = URLEncodedBase64(challengeStr)

        relyingParty = try container.decode(PublicKeyCredentialRelyingPartyEntity.self, forKey: .relyingParty)
        publicKeyCredentialParameters = try container.decode([PublicKeyCredentialParameters].self, forKey: .publicKeyCredentialParameters)
        user = try container.decode(PublicKeyCredentialUserEntity.self, forKey: .user)
        authenticatorSelectionCriteria = try container.decodeIfPresent(AuthenticatorSelectionCriteria.self, forKey: .authenticatorSelectionCriteria)

        if let timeoutDouble = try container.decodeIfPresent(Double.self, forKey: .timeout) {
            timeout = Duration.milliseconds(timeoutDouble)
        } else {
            timeout = nil
        }

        excludeCredentials = try container.decodeIfPresent([PublicKeyCredentialDescriptor].self, forKey: .excludeCredentials)
        attestation = try container.decodeIfPresent(String.self, forKey: .attestation)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encode(challenge.asString(), forKey: .challenge)
        try container.encode(relyingParty, forKey: .relyingParty)
        try container.encode(publicKeyCredentialParameters, forKey: .publicKeyCredentialParameters)
        try container.encode(user, forKey: .user)
        try container.encodeIfPresent(authenticatorSelectionCriteria, forKey: .authenticatorSelectionCriteria)
        try container.encodeIfPresent(timeout?.milliseconds, forKey: .timeout)
        try container.encodeIfPresent(excludeCredentials, forKey: .excludeCredentials)
        try container.encodeIfPresent(attestation, forKey: .attestation)
    }
}

// MARK: - Credential parameters
/// From §5.3 (https://w3c.github.io/TR/webauthn/#dictionary-credential-params)
public struct PublicKeyCredentialParameters: Codable, Sendable {
    /// The type of credential to be created. At the time of writing always ``CredentialType/publicKey``.
    public let type: CredentialType
    /// The cryptographic signature algorithm with which the newly generated credential will be used, and thus also
    /// the type of asymmetric key pair to be generated, e.g., RSA or Elliptic Curve.
    public let alg: COSEAlgorithmIdentifier

    private enum CodingKeys: String, CodingKey {
        case type
        case alg
    }

    /// Creates a new `PublicKeyCredentialParameters` instance.
    ///
    /// - Parameters:
    ///   - type: The type of credential to be created. At the time of writing always ``CredentialType/publicKey``.
    ///   - alg: The cryptographic signature algorithm to be used with the newly generated credential.
    ///     For example RSA or Elliptic Curve.
    public init(type: CredentialType = .publicKey, alg: COSEAlgorithmIdentifier) {
        self.type = type
        self.alg = alg
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        let typeStr = try container.decode(String.self, forKey: .type)
        type = CredentialType(typeStr)

        let algInt = try container.decode(Int.self, forKey: .alg)
        alg = COSEAlgorithmIdentifier(rawValue: algInt) ?? .unknown
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encode(type.rawValue, forKey: .type)
        try container.encode(alg.rawValue, forKey: .alg)
    }
}

extension Array where Element == PublicKeyCredentialParameters {
    /// A list of `PublicKeyCredentialParameters` Swift WebAuthn currently supports.
    public static var supported: [Element] {
        COSEAlgorithmIdentifier.allCases.map {
            Element.init(type: .publicKey, alg: $0)
        }
    }
}

// MARK: - Credential entities

/// From §5.4.2 (https://www.w3.org/TR/webauthn/#sctn-rp-credential-params).
/// The PublicKeyCredentialRelyingPartyEntity dictionary is used to supply additional Relying Party attributes when
/// creating a new credential.
public struct PublicKeyCredentialRelyingPartyEntity: Codable, Sendable {
    /// A unique identifier for the Relying Party entity.
    public let id: String

    /// A human-readable identifier for the Relying Party, intended only for display. For example, "ACME Corporation",
    /// "Wonderful Widgets, Inc." or "ОАО Примертех".
    public let name: String
}

 /// From §5.4.3 (https://www.w3.org/TR/webauthn/#dictionary-user-credential-params)
 /// The PublicKeyCredentialUserEntity dictionary is used to supply additional user account attributes when
 /// creating a new credential.
 ///
 /// When encoding using `Encodable`, `id` is base64url encoded.
public struct PublicKeyCredentialUserEntity: Codable, Sendable {
    /// Generated by the Relying Party, unique to the user account, and must not contain personally identifying
    /// information about the user.
    public let id: Data

    /// A human-readable identifier for the user account, intended only for display. It helps the user to
    /// distinguish between user accounts with similar `displayName`s. For example, two different user accounts
    /// might both have the same `displayName`, "Alex P. Müller", but might have different `name` values "alexm",
    /// "alex.mueller@example.com" or "+14255551234".
    public let name: String

    /// A human-readable name for the user account, intended only for display.
    public let displayName: String

    private enum CodingKeys: String, CodingKey {
        case id
        case name
        case displayName
    }

    /// Creates a new ``PublicKeyCredentialUserEntity`` from id, name and displayName
    public init(id: Data, name: String, displayName: String) {
        self.id = id
        self.name = name
        self.displayName = displayName
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        let idStr = try container.decode(String.self, forKey: .id)
        id = Data(URLEncodedBase64(idStr).decodedBytes ?? [])

        name = try container.decode(String.self, forKey: .name)
        displayName = try container.decode(String.self, forKey: .displayName)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encode(id.base64URLEncodedString().asString(), forKey: .id)
        try container.encode(name, forKey: .name)
        try container.encode(displayName, forKey: .displayName)
    }
}
